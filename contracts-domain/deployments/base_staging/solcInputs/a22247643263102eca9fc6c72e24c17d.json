{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@zk-email/contracts/utils/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6;\n\n// https://github.com/nalinbhardwaj/ethdosnumber/blob/main/ethdos-contracts/src/HexStrings.sol\nlibrary StringUtils {\n    bytes16 internal constant ALPHABET = \"0123456789abcdef\";\n    uint256 internal constant DEFAULT_PACK_SIZE = 31;\n\n    /// @notice Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n    /// @dev Credit to Open Zeppelin under MIT license https://github.com/OpenZeppelin/openzeppelin-contracts/blob/243adff49ce1700e0ecb99fe522fb16cff1d1ddc/contracts/utils/Strings.sol#L55\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    function toHexStringNoPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length);\n        for (uint256 i = buffer.length; i > 0; i--) {\n            buffer[i - 1] = ALPHABET[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(bytes32 value) internal pure returns (string memory) {\n        return toString(abi.encodePacked(value));\n    }\n\n    function toString(address account) internal pure returns (string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    function stringEq(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    function toString(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        str[0] = \"0\";\n        str[1] = \"x\";\n        for (uint256 i = 0; i < data.length; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n\n    // 1 packed byte = packSize (usually 31) normal bytes, all in one 255/256-bit value\n    // Note that this is not 32 due to the field modulus of circom\n    function convertPackedByteToString(uint256 packedByte, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint256[] memory packedBytes = new uint256[](1);\n        packedBytes[0] = packedByte;\n        return convertPackedBytesToString(packedBytes, packSize, packSize);\n    }\n\n    // Note: This convenience function removes the max string length check, which may cause misalignment with the circom\n    // If using this, then the circom needs to rangecheck packed length in the circuit itself\n    // This defaults to 31 bytes per packed byte\n    function convertPackedBytesToString(uint256[] memory packedBytes) \n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        return convertPackedBytesToString(packedBytes, packedBytes.length * DEFAULT_PACK_SIZE, DEFAULT_PACK_SIZE);\n    }\n\n    // Unpacks uint256s into bytes and then extracts the non-zero characters\n    // Only extracts contiguous non-zero characters and ensures theres only 1 such state\n    // Note that unpackedLen may be more than packedBytes.length * 8 since there may be 0s\n    // signals is the total number of signals (i.e. bytes) packed into the packedBytes. it defaults to packedBytes.length * packSize\n    function convertPackedBytesToString(uint256[] memory packedBytes, uint256 signals, uint256 packSize)\n        internal\n        pure\n        returns (string memory extractedString)\n    {\n        uint8 state = 0;\n        // bytes: 0 0 0 0 y u s h _ g 0 0 0\n        // state: 0 0 0 0 1 1 1 1 1 1 2 2 2\n        bytes memory nonzeroBytesArray = new bytes(packedBytes.length * packSize);\n        uint256 nonzeroBytesArrayIndex = 0;\n        for (uint16 i = 0; i < packedBytes.length; i++) {\n            uint256 packedByte = packedBytes[i];\n            uint8[] memory unpackedBytes = new uint8[](packSize);\n            for (uint256 j = 0; j < packSize; j++) {\n                unpackedBytes[j] = uint8(packedByte >> (j * 8));\n            }\n            for (uint256 j = 0; j < packSize; j++) {\n                uint256 unpackedByte = unpackedBytes[j]; //unpackedBytes[j];\n                if (unpackedByte != 0) {\n                    nonzeroBytesArray[nonzeroBytesArrayIndex] = bytes1(uint8(unpackedByte));\n                    nonzeroBytesArrayIndex++;\n                    if (state % 2 == 0) {\n                        state += 1;\n                    }\n                } else {\n                    if (state % 2 == 1) {\n                        state += 1;\n                    }\n                }\n                packedByte = packedByte >> 8;\n            }\n        }\n        // TODO: You might want to assert that the state is exactly 1 or 2\n        // If not, that means empty bytse have been removed from the middle and things have been concatenated.\n        // We removed due to some tests failing, but this is not ideal and the require should be uncommented as soon as tests pass with it.\n\n        // require(state == 1 || state == 2, \"Invalid final state of packed bytes in email; more than two non-zero regions found!\");\n        require(state >= 1, \"No packed bytes found! Invalid final state of packed bytes in email; value is likely 0!\");\n        require(nonzeroBytesArrayIndex <= signals, \"Packed bytes more than allowed max number of signals!\");\n        string memory returnValue = removeTrailingZeros(string(nonzeroBytesArray));\n        return returnValue;\n        // Have to end at the end of the email -- state cannot be 1 since there should be an email footer\n    }\n\n    function bytes32ToString(bytes32 input) internal pure returns (string memory) {\n        uint256 i;\n        for (i = 0; i < 32 && input[i] != 0; i++) {}\n        bytes memory resultBytes = new bytes(i);\n        for (i = 0; i < 32 && input[i] != 0; i++) {\n            resultBytes[i] = input[i];\n        }\n        return string(resultBytes);\n    }\n\n    // sliceArray is used to slice an array of uint256s from start-end into a new array of uint256s\n    function sliceArray(uint256[] memory input, uint256 start, uint256 end) internal pure returns (uint256[] memory) {\n        require(start <= end && end <= input.length, \"Invalid slice indices\");\n        uint256[] memory result = new uint256[](end - start);\n        for (uint256 i = start; i < end; i++) {\n            result[i - start] = input[i];\n        }\n        return result;\n    }\n\n    // stringToUint is used to convert a string like \"45\" to a uint256 4\n    function stringToUint(string memory s) internal pure returns (uint256) {\n        bytes memory b = bytes(s);\n        uint256 result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            // TODO: Currently truncates decimals\n            if (b[i] == 0x2E) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    // getDomainFromEmail is used to extract the domain from an email i.e. the part after the @\n    function getDomainFromEmail(string memory fromEmail) internal pure returns (string memory) {\n        bytes memory emailBytes = bytes(fromEmail);\n        uint256 atIndex;\n        for (uint256 i = 0; i < emailBytes.length; i++) {\n            if (emailBytes[i] == \"@\") {\n                atIndex = i;\n                break;\n            }\n        }\n\n        bytes memory domainBytes = new bytes(emailBytes.length - atIndex - 1);\n        for (uint256 j = 0; j < domainBytes.length; j++) {\n            domainBytes[j] = emailBytes[atIndex + 1 + j];\n        }\n        return bytes32ToString(bytes32(bytes(domainBytes)));\n    }\n\n    function removeTrailingZeros(string memory input) public pure returns (string memory) {\n        bytes memory inputBytes = bytes(input);\n        uint256 endIndex = inputBytes.length;\n\n        for (uint256 i = 0; i < inputBytes.length; i++) {\n            if (inputBytes[i] == 0) {\n                endIndex = i;\n                break;\n            }\n        }\n\n        bytes memory resultBytes = new bytes(endIndex);\n        for (uint256 i = 0; i < endIndex; i++) {\n            resultBytes[i] = inputBytes[i];\n        }\n\n        return string(resultBytes);\n    }\n\n    // Upper/lower string utils from https://github.com/willitscale/solidity-util/blob/master/lib/Strings.sol\n    /**\n     * Upper\n     *\n     * Converts all the values of a string to their corresponding upper case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to upper case\n     * @return string\n     */\n    function upper(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _upper(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     *\n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string\n     */\n    function lower(string memory _base) public pure returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint256 i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Upper\n     *\n     * Convert an alphabetic character to upper case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to upper case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a lower case otherwise returns the original value\n     */\n    function _upper(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\n            return bytes1(uint8(_b1) - 32);\n        }\n\n        return _b1;\n    }\n\n    /**\n     * Lower\n     *\n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1) private pure returns (bytes1) {\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n"
    },
    "contracts/external/interfaces/IKeyHashAdapterV2.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface IKeyHashAdapterV2 {\n    function addMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function removeMailServerKeyHash(bytes32 _mailserverKeyHash) external;\n    function getMailServerKeyHashes() external view returns (bytes32[] memory);\n    function isMailServerKeyHash(bytes32 _mailserverKeyHash) external view returns (bool);\n}\n"
    },
    "contracts/external/interfaces/INullifierRegistry.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\ninterface INullifierRegistry {\n    function addNullifier(bytes32 _nullifier) external;\n    function isNullified(bytes32 _nullifier) external view returns(bool);\n}\n"
    },
    "contracts/external/lib/StringConversionUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\n// Building on zk-email's StringUtils library we add the ability to handle decimals when\n// converting from string to Uint\nlibrary StringConversionUtils {\n    \n    /**\n     * @notice Function that parses numbers returned as strings including floating point numbers. Returned floating point\n     * numbers are to have the desired amount of decimal specified. If the stringified version of the floating point\n     * number has more decimal places than desired then the function will revert in order to be maximally safe. If\n     * the returned number has multiple floating points then the function will revert.\n     *\n     * Examples: _s = \"12.34\", _expectedDecimals = 6 => 12340000\n     *           _s = \"12.34\", _expectedDecimals = 2 => 1234\n     *           _s = \"12.34\", _expectedDecimals = 1 => REVERT (we never want loss of precision only addition)\n     *           _s = \"12.34.56\", _expectedDecimals = 6 => REVERT (Invalid number)\n     *\n     * @param _s                    String being processed\n     * @param _desiredDecimals      Desired amount of decimal places\n     */\n    function stringToUint(string memory _s, uint256 _desiredDecimals) internal pure returns (uint256) {\n        return stringToUint(_s, 0x2E, _desiredDecimals);\n    }\n\n    function stringToUint(\n        string memory _s,\n        bytes1 _decimalCharacter,\n        uint256 _desiredDecimals\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        bytes memory b = bytes(_s);\n\n        uint256 result = 0;\n        uint256 decimalPlaces = 0;\n\n        bool decimals = false;\n        for (uint256 i = 0; i < b.length; i++) {\n            if (b[i] >= 0x30 && b[i] <= 0x39) {\n                result = result * 10 + (uint256(uint8(b[i])) - 48);\n            }\n\n            if (decimals) {\n                decimalPlaces++;\n            }\n\n            if (b[i] == _decimalCharacter) {\n                require(decimals == false, \"String has multiple decimals\");\n                decimals = true;\n            }\n        }\n\n        require(decimalPlaces <= _desiredDecimals, \"String has too many decimal places\");\n        return result * (10 ** (_desiredDecimals - decimalPlaces));\n    }\n\n    /**\n     * @notice Function that returns a substring from _startIndex to _endIndex (non-inclusive).\n     *\n     * @param _str           String being processed\n     * @param _startIndex    Index to start parsing from\n     * @param _endIndex      Index to stop parsing at (index not included in result)\n     */\n    function substring(string memory _str, uint _startIndex, uint _endIndex) internal pure returns (string memory ) {\n        bytes memory strBytes = bytes(_str);\n        bytes memory result = new bytes(_endIndex-_startIndex);\n        for(uint i = _startIndex; i < _endIndex; i++) {\n            result[i-_startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    function replaceString(\n        string memory _str,\n        string memory _lookupValue,\n        string memory _replaceValue\n    )\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory strBytes = bytes(_str);\n        bytes memory lookupBytes = bytes(_lookupValue);\n\n        uint256 lookupIndex = indexOf(_str, _lookupValue);\n        if (lookupIndex == type(uint256).max) {\n            return _str;\n        }\n\n        // Split the original string into two parts: before and after the keyword\n        string memory beforeKeyword = substring(_str, 0, lookupIndex);\n        string memory afterKeyword = substring(_str, lookupIndex + lookupBytes.length, strBytes.length);\n        \n        return string.concat(beforeKeyword, _replaceValue, afterKeyword);\n    }\n\n    function indexOf(string memory str, string memory substr) internal pure returns (uint) {\n        bytes memory strBytes = bytes(str);\n        bytes memory substrBytes = bytes(substr);\n        \n        if (strBytes.length < substrBytes.length) return type(uint256).max;\n        \n        for (uint i = 0; i <= strBytes.length - substrBytes.length; i++) {\n            bool found = true;\n            for (uint j = 0; j < substrBytes.length; j++) {\n                if (strBytes[i + j] != substrBytes[j]) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) return i;\n        }\n        \n        return type(uint256).max;\n    }\n\n    function stringComparison(string memory _a, string memory _b) internal pure returns (bool) {\n        return (keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b)));\n    }\n}\n"
    },
    "contracts/external/processors/EmailBaseProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IKeyHashAdapterV2 } from \"../interfaces/IKeyHashAdapterV2.sol\";\nimport { INullifierRegistry } from \"../interfaces/INullifierRegistry.sol\";\n\npragma solidity ^0.8.18;\n\ncontract EmailBaseProcessor is Ownable {\n\n    /* ============ Modifiers ============ */\n    modifier onlyExchange() {\n        require(msg.sender == exchange, \"Only exchange can call this function\");\n        _;\n    }\n\n    /* ============ State Variables ============ */\n    address public immutable exchange;\n    INullifierRegistry public nullifierRegistry;\n    bytes public emailFromAddress;\n    uint256 public timestampBuffer;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _exchange,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress,\n        uint256 _timestampBuffer\n    )\n        Ownable()\n    {\n        exchange = _exchange;\n        nullifierRegistry = _nullifierRegistry;\n        emailFromAddress = bytes(_emailFromAddress);\n        timestampBuffer = _timestampBuffer;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * @notice ONLY OWNER: Sets the from email address for validated emails. Check that email address is properly\n     * padded (if necessary). Padding will be dependent on if unpacking functions cut trailing 0s or not.\n     *\n     * @param _emailFromAddress    The from email address for validated emails, MUST BE PROPERLY PADDED\n     */\n    function setEmailFromAddress(string memory _emailFromAddress) external onlyOwner {\n        emailFromAddress = bytes(_emailFromAddress);\n    }\n\n    /**\n     * @notice ONLY OWNER: Sets the timestamp buffer for validated emails. This is the amount of time in seconds\n     * that the timestamp can be off by and still be considered valid. Necessary to build in flexibility with L2\n     * timestamps.\n     *\n     * @param _timestampBuffer    The timestamp buffer for validated emails\n     */\n    function setTimestampBuffer(uint256 _timestampBuffer) external onlyOwner {\n        timestampBuffer = _timestampBuffer;\n    }\n\n    /* ============ External Getters ============ */\n\n    function getEmailFromAddress() external view returns (bytes memory) {\n        return emailFromAddress;\n    }\n\n\n    /* ============ Internal Functions ============ */\n\n    function _validateAndAddNullifier(bytes32 _nullifier) internal {\n        require(!nullifierRegistry.isNullified(_nullifier), \"Nullifier has already been used\");\n        nullifierRegistry.addNullifier(_nullifier);\n    }\n}\n"
    },
    "contracts/interfaces/ITransferDomainProcessor.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\ninterface ITransferDomainProcessor {\n\n    struct TransferProof {\n        uint256[2] a;\n        uint256[2][2] b;\n        uint256[2] c;\n        uint256[10] signals;\n    }\n\n    function processProof(\n        TransferProof calldata _proof\n    ) \n        external \n        returns (\n            bytes32 dkimKeyHash, \n            bytes32 hashedReceiverId, \n            string memory domainName, \n            uint256 bidId\n        );\n}"
    },
    "contracts/TransferDomainProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport { StringUtils } from \"@zk-email/contracts/utils/StringUtils.sol\";\n\nimport { EmailBaseProcessor } from \"./external/processors/EmailBaseProcessor.sol\";\nimport { INullifierRegistry } from \"./external/interfaces/INullifierRegistry.sol\";\nimport { StringConversionUtils } from \"./external/lib/StringConversionUtils.sol\";\n\nimport { Groth16Verifier } from \"./verifiers/namecheap_transfer_verifier.sol\";\nimport { ITransferDomainProcessor } from \"./interfaces/ITransferDomainProcessor.sol\";\n\npragma solidity ^0.8.18;\n\ncontract TransferDomainProcessor is Groth16Verifier, ITransferDomainProcessor, EmailBaseProcessor {\n    \n    using StringUtils for uint256[];\n    using StringConversionUtils for string;\n\n    /* ============ Constants ============ */\n    uint256 constant PACK_SIZE = 31;\n\n    /* ============ Constructor ============ */\n    constructor(\n        address _exchange,\n        INullifierRegistry _nullifierRegistry,\n        string memory _emailFromAddress,\n        uint256 _timestampBuffer\n    )\n        Groth16Verifier()\n        EmailBaseProcessor(\n            _exchange,\n            _nullifierRegistry,\n            _emailFromAddress,\n            _timestampBuffer\n        )\n    {}\n    \n    /* ============ External Functions ============ */\n\n    function processProof(\n        TransferProof calldata _proof\n    )\n        external\n        override\n        onlyExchange\n        returns (\n            bytes32 dkimKeyHash,\n            bytes32 hashedReceiverId,\n            string memory domainName, \n            uint256 bidId\n        )\n    {\n        require(this.verifyProof(_proof.a, _proof.b, _proof.c, _proof.signals), \"Invalid Proof\");\n\n        // Signal [0] is the DKIM key hash\n        dkimKeyHash = bytes32(_proof.signals[0]);\n\n        // Signals [1:2] are the packed from email address\n        string memory fromEmail = _parseSignalArray(_proof.signals, 1, 2);\n        require(\n            keccak256(abi.encodePacked(fromEmail)) == keccak256(emailFromAddress), \n            \"Invalid email from address\"\n        );\n        \n        // Signals [2:7] are packed domain name\n        domainName = _parseSignalArray(_proof.signals, 2, 7);\n\n        // Signal [7] is packed hashed namecheap id to which domain was transferred\n        hashedReceiverId = bytes32(_proof.signals[7]);\n\n        // Check if email has been used previously, if not nullify it so it can't be used again\n        _validateAndAddNullifier(bytes32(_proof.signals[8]));\n\n        // Signal [9] is bidId\n        bidId = _proof.signals[9];\n    }\n    \n    /* ============ Internal Functions ============ */\n\n    function _parseSignalArray(uint256[10] calldata _signals, uint8 _from, uint8 _to) \n        internal \n        pure \n        returns (string memory) \n    {\n        uint256[] memory signalArray = new uint256[](_to - _from);\n        for (uint256 i = _from; i < _to; i++) {\n            signalArray[i - _from] = _signals[i];\n        }\n\n        return signalArray.convertPackedBytesToString(signalArray.length * PACK_SIZE, PACK_SIZE);\n    }\n}\n"
    },
    "contracts/verifiers/namecheap_transfer_verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Groth16Verifier {\n    // Scalar field size\n    uint256 constant r    = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 16428432848801857252194528405604668803277877773566238944394625302971855135431;\n    uint256 constant alphay  = 16846502678714586896801519656441059708016666274385668027902869494772365009666;\n    uint256 constant betax1  = 3182164110458002340215786955198810119980427837186618912744689678939861918171;\n    uint256 constant betax2  = 16348171800823588416173124589066524623406261996681292662100840445103873053252;\n    uint256 constant betay1  = 4920802715848186258981584729175884379674325733638798907835771393452862684714;\n    uint256 constant betay2  = 19687132236965066906216944365591810874384658708175106803089633851114028275753;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 1482036359054785987758983791437636255761203148422438653991915394359246721370;\n    uint256 constant deltax2 = 10001792791670748994653802587965307894251588681124493339739643276539399327199;\n    uint256 constant deltay1 = 12929924181374602539079631103652565558658437684289021022192643357266276129313;\n    uint256 constant deltay2 = 18621234594885561836856860416599021020030685616956494244557460320066348275486;\n\n\n    uint256 constant IC0x = 13679841311419499947196488030563927052737833631831087839800108582001619982756;\n    uint256 constant IC0y = 14398831345642232008615460969424497321419317733481671851297924133275173512121;\n\n    uint256 constant IC1x = 2408377228439232698160803002782752816762776284505564408880728084177561554601;\n    uint256 constant IC1y = 4562823341627914579340945271513298981280656371775082655869052525475797696282;\n\n    uint256 constant IC2x = 11698161615520749679058702638780643731158760523880360973169686160750874723717;\n    uint256 constant IC2y = 5482072052337866918379448154185642235470279334903213679209093769947335616093;\n\n    uint256 constant IC3x = 20768666777689851453960746019474086479608334345599593721826216429323116802773;\n    uint256 constant IC3y = 144384800173925255346616036805594882403322575509153153064641653383667680325;\n\n    uint256 constant IC4x = 5484190953638831817876258480017744165730276029855186594303418421204653869358;\n    uint256 constant IC4y = 2388977283212189651166234573571473197529151009141226183250075013106275368678;\n\n    uint256 constant IC5x = 17286960896074201491464437213186707946980083024758675396143906384940172672768;\n    uint256 constant IC5y = 5559244286107427512674714237837993184640251130340291817174978126569513551048;\n\n    uint256 constant IC6x = 5981106732853641044464779767035945345345676221237979116689771873940770600376;\n    uint256 constant IC6y = 16757892553277885270560523048286665969871413522533097385031102756444326127164;\n\n    uint256 constant IC7x = 21137398581361954385460769732122488724166715754152295898647889069721843981111;\n    uint256 constant IC7y = 17117057588842742212408259815326568334655191160255595656714878965037331239848;\n\n    uint256 constant IC8x = 16214254713514974179767304814474510985714849436687773447034352068497147314860;\n    uint256 constant IC8y = 13028412764820438875408464005100529475148539560770504369038194564947786526663;\n\n    uint256 constant IC9x = 18408046483761423912872515862380512887546745528686003625682162751275305246737;\n    uint256 constant IC9y = 14576373605584916924675717896952852805094073315049779994296007237958279154545;\n\n    uint256 constant IC10x = 19754959014163302021033520556658948350285362357974437446624957863682467085464;\n    uint256 constant IC10y = 6837772045404055003823337103437422613565931626793512604498169200205461541951;\n\n\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[10] calldata _pubSignals) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, r)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n\n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n\n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n\n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n\n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n\n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n\n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n\n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n\n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n\n            checkField(calldataload(add(_pubSignals, 0)))\n\n            checkField(calldataload(add(_pubSignals, 32)))\n\n            checkField(calldataload(add(_pubSignals, 64)))\n\n            checkField(calldataload(add(_pubSignals, 96)))\n\n            checkField(calldataload(add(_pubSignals, 128)))\n\n            checkField(calldataload(add(_pubSignals, 160)))\n\n            checkField(calldataload(add(_pubSignals, 192)))\n\n            checkField(calldataload(add(_pubSignals, 224)))\n\n            checkField(calldataload(add(_pubSignals, 256)))\n\n            checkField(calldataload(add(_pubSignals, 288)))\n\n            checkField(calldataload(add(_pubSignals, 320)))\n\n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n             return(0, 0x20)\n         }\n     }\n }"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yulDetails": {
          "optimizerSteps": "u"
        }
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}